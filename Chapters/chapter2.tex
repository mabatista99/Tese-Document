%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter2.tex
%% NOVA thesis document file
%%
%% Chapter with the template manual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter2.tex}%

\chapter{State-Of-The-Art}
\label{cha:State-Of-The-Art}

This chapter provides a view of the state-of-the-art of web development as well
as event management platforms and connection with iot devices.
Firstly, it presents an overview on how the web development is structured and
explains the concept of software architecture and some of its patterns. Then the
main two parts of web development, the frontend (both for web and mobile) and
backend, are discussed along with its frameworks.

In a second part, some event management platform solutions will be reviewed
along with its technologies.

Finally we will look on how we can connect a IoT device with our platform and
how its being already done in other solutions.

\section{System Architecture Patterns}

\subsection{Monolithic Architecture}
A monolithic architecture is a software design pattern in which all parts ---
such as the \gls{UI}, business logic and data access layers --- are tightly
coupled and deployed together as a single unit\cite{7436659,10031648}. This
was the most popular approach for decades due to how simple it is, specially in
the early stages of software development\cite{Garlan2018}.

\subsubsection{Advantages}
Despite some problems, monoliths have some advantages on the other architectures,
specially for smaller applications or early-stage development:
\begin{itemize}
	\item \textbf{Simplicity}

	      The monolithic architecture is probably the simplest way of structuring a
	      project and monolithic solutions are easier to design, develop and deploy
	      than other solutions.
	      Having the code in a single codebase removes the need for complex
	      integration, making it more attractive for smaller teams with limited
	      resources or expertise.
	\item \textbf{Efficiency}

	      Since there is a single application in monolithic systems, there are no
	      services integrations and developers can debug without dealing with
	      inter-service communications. Testing is also easier because all of the
	      components are located in the same codebase and run in the same environment.
	\item \textbf{Straightforward Deployment}

	      Deploying a monolithic application involves managing a single artifact. This
	      reduces operational complexity compared to systems where deployment
	      pipelines must coordinate multiple services.
\end{itemize}
\subsubsection{Challenges}
For bigger architectures, this solution might not be adequate as several
challenges appear as applications grow in size and complexity.
\begin{itemize}
	\item \textbf{Scalability Constraints}

	      As mentioned above, Scaling a monolithic system can be much harder when
	      compared with other modular architectures. Let's say that hipotetically,
	      an application is composed of three modules. One is in constant
	      overload and needs to be scaled with urgency, the second has some peaks of
	      usage but doesn't require to be scaled, and the third is barely used and
	      could be ajusted to use less resources. In an architecture where this
	      modules are separated for example in three services, scaling publishers
	      efficient and we can scale up the first service and scale down the third.
	      However, in a monolith, we can only scale everything as one, meaning there
	      can be modules that force the scaling of unrelated components unnecesarily.
	      In the example above, we would need to scale the whole system, including
	      the third module that is already wasting more resources that it needs.
	\item \textbf{Maintenance}

	      Monoliths are prone to tech debt accumulation over time. The lack
	      of modularity present in these systems frequently results in what is known as a
	      "big ball of mud", meaning that dependencies between the system's elements are
	      unclear, slowing the development process and making maintanance an
	      hard and continuous process\cite{7333476}.

	\item \textbf{Deployment Risk}

	      Every change in the codebase requires all the application to be redeployed,
	      increasing the risk of downtime and complicating release cycles. If an error
	      is deployed to the public environment, it can cause the whole system to go
	      down while in modular systems, if a problem is deployed in one of the
	      modules, the others are independent and can still run even if the one with
	      the problem is down, meaning that only part of the system is unavailable.

	\item \textbf{Lack of Flexibility}

	      Since all of the application's logic resides in a single codebase, it will
	      likely be enforced that everything should be developed using an uniform
	      technology stack. In architectures that have the application divided in
	      modules is possible for each module to have its own technology stack,
	      which can facilitate the development of some specific features that are
	      easier to do with specific technologies.
\end{itemize}

\subsection{Client-Server Architecture}
The client-server architecture is a software design paradigm that devides the
system into two types, the clients and the servers. The clients are service
requesters responsible for initiating requests tipically as consequence of user
interaction, and can be for example a website or a mobile app. On the other
side, servers process that requests, access the data if needed and return the
adequate responses. This separation of concerns allows one server to provide
consistent data to multiple clients.
Examples include email systems, where clients(e.g. email software) interact with
a centralized server that is responsible for sending and storing the emails.

\subsubsection{Advantages}
The client-side architecture has several benefits:
\begin{itemize}
	\item \textbf{Modularity}

	      A separation between clients and servers allows for independent development,
	      testing and maintenance, improving flexibility in application design.

	\item \textbf{Data Consistency}

	      Multiple clients can access a single server, and since this server is the
	      only thing managing the resources it ensures that the data received by the
	      clients is consistent between them. This also ensures that clients can access
	      the most recent and accurate information.

	\item \textbf{Scalability}

	      Horizontal scaling, where additional servers can be added, altought limited
	      by replication of the entire server, enables the system to handle increased
	      demand.
\end{itemize}
\subsubsection{Challenges}
The Client-Server Architecture has also its disadvantages:
\begin{itemize}
	\item \textbf{Single Point of Failure}

	      All the resources are managed in a centralized server, which means that if
	      the server fails, all connected clients are affected. Despite this being a
	      serious concern, there are techniques like load balancing that help
	      mitigating this risk.

	\item \textbf{Scalability Constraints}

	      Although scalability was mentioned above as an advantage, the scalability
	      of client-server achitectures is very limited. Even with the decoupling of
	      clients from servers, horizontal scaling can only happen by deploying the
	      same server to several machines and vertical scaling can only happen by
	      increasing the hardware for the whole server. This is limited in modularity
	      and it also increases the complexity by adding the necessity of having
	      load balancers and data synchronization across servers.

	\item \textbf{Latency}

	      Communication between clients and servers over a network introduce delays,
	      which can be a problem for applications that require real-time
	      responses.

\end{itemize}

\subsection{Microservices Architecture}
The microservices architecture is a system design pattern that divides an
application into several other independently deployed applications called
microservices.
In this solution, the modules communicate between each other through
synchronous communications using APIs based on technologies like like
\gls{HTTP}, \gls{gRPC}, or GraphQL, or through asynchronous communication,
adopting tools like message brokers or event streaming platforms.

\subsubsection{Advantages}

\begin{itemize}
	\item \textbf{Scalability}

	      Microservices are independent applications with its own codebase, deployed
	      separately and in most cases with their individual database. For this reason
	      each service can be scaled independently based on demand. A service with
	      high demand like for example user authentication can scale separately from
	      services with less workload.

	\item \textbf{Fault Isolation}

	      Another benefit of having the logic separated into services is that when
	      a failure occurs in a service, the others will unlikely be affected. For
	      example, when a store website has a problem with its payment service, the
	      users might not be able to pay but they can still browse the website and
	      do other things like managing the profile or adding products to the cart.

	\item \textbf{Technology Diversity}

	      Each service is an independent application, which means that each service
	      can be developed using different technologies. This allows the service to
	      be developed using technologies that are more suitable for its own purpose.

\end{itemize}

\subsubsection{Challenges}
\begin{itemize}
	\item \textbf{Complexity}

	      Managing multiple services is much more complex than managing a single
	      application. Deployment and maintanance efforts are multiplied, which can
	      lead to operational overhead. The heavy use of monitoring tools can be
	      helpful, or even required in this kind of solutions.

	\item \textbf{Dependency Management}

	      In these architectures, services often depend on each other, and despite
	      fault isolation being pointed as an advantage, if the dependencies are not
	      properly managed a failure can lead to successive failures on other modules.
	      When there are two services that need to be change in order to add or update
	      a feature, the first service to be deployed need to be compatible with the
	      previous version of the other, otherwise there will be problems while they
	      are not both properly deployed.
	      Observability tools like tracing and logging are essencial to prevent and
	      diagnose this king of issues.
\end{itemize}


\subsection{Event-Driven Architecture}
The event-driven architecture is a system design patter where the components
are loosed coupled, communicating by events. Events are messages that are sent
by a system in reaction to a change in its state. This communication is made
between an event producer, and an event subscriber. Event Producers generate the
events and send the messages to a broker, Event Subscribers subscribe to
events and react to them. Both these parts are agnostic to each other, meaning
that the producers send the events not knowing who will receive them and the
subscribers receive the events not knowing who sent them. This is possible
because of the broker. Event Brokers, like Apache Kafka or RabbitMQ are
responsible for routing the events from the producers to the subscribers through
features like message queuing and topic-based routing.

\subsubsection{Advantages}
\begin{itemize}
	\item \textbf{Loosed Coupling}

	      The communication is done indirectly, reducing the interdependencies which
	      are a significant point of failure.

	\item \textbf{Scaling}

	      Since the communication can be done asynchronously and through event brokers,
	      the events don't need to be processed in real-time and are instead added to
	      a queue allowing these systems to support an high volume of events. This
	      reduces the needing for scaling, which is already an easier process because
	      of the modularity present in this architecture.

	\item \textbf{Fault Tolerance}

	      Components of an event-driven architecture operate independently, meaning
	      that if a component fails the system can continue functioning. In this
	      case, due to the existence of an event broker, the messages are stored in
	      this intermediary until they are processed, reducing the probability of
	      loosing data.

	\item \textbf{Flexibility in adding features}

	      By decoupling producers from subscribers, a new consumer can be added
	      and subscribe to existing events. This doesn't require any change in the
	      producer in order to work, which facilitates the extension of the
	      system.

	\item \textbf{Real-Time capabilities}

	      Despite what was said above that the events don't need to be processed
	      in real-time, they can be configured to process and respond to events
	      as they occur, making it ideal for applications which require real-time
	      responsiveness.
\end{itemize}

\subsubsection{Challenges}
\begin{itemize}
	\item \textbf{Event Ordering and Duplication}

	      Making sure that events are queued in the correct order and that they are
	      processed only once can be a difficult task because of the concurrency
	      that is characteristic of these systems.

	\item \textbf{Debugging}

	      The assynchronous communication complicates the debugging process.
	      Observability tool are essencial to diagnose problems.

	\item \textbf{Infrastructure Overhead}

	      The process of setting up and maintaining the event brokers, monitoring
	      systems introduce complexity on the operational side.
\end{itemize}

\subsection{Applications and Use Cases}
Every architecture has its own advantages and disadvantages, but they all have
their place in the software industry.

Monolithic systems are a great choice for simpler and smaller applications.
Startups and small businesses usually start by implementing this solution as
its infrastructure is very simple, and it's relatively fast to have an initial
functional product. This architecture is often used as a starting point, and
eventually, as the application grows, it's migrated to more complex architectures.
Examples of real-world applications are basic e-commerce platforms, content
management systems and small desktop applications.

The client-side architecture is popular among web applications. Most of the
websites use this architecture where browsers act as clients that interact with
centralized web servers. Another wide applicatios for this structures are email
systems and database applications. In email systems, the servers communicate
with clients like Microsoft Outlook or Gmail using protocols like IMAP or SMTP.
In database applications, clients access centralized database servers using
SQL queries for data retrieval and manipulation.

Microservices architectures have become the go-to solution for more complex
systems. It's widely used in bigger e-commerce applications where the application
is divided into several microservices like user authentication, payment processing,
shipping processing, etc. Streaming platforms like Netflix also tend to use this
solution, dividing the application into services for content recommendation, user
preferences, subscription handling, etc.

Lastly, the event-driven architecture shines in products where real-time
responsiveness is crucial. It's widely used in Internet of Things systems,in
applications like industrial monitoring, home automation, and environmental
sensing where IoT devices send events to be processed in real-time.

It's also common to mix different architectures in the same system using
hybrid solutions. E-commerce platforms, for example, where referenced above in
multiple architectures as these platforms can use microsservices for processing
payments or user authentication and event-driven architecture to process orders.

\section{Backend Development}
Managing the underlying logic, data storage, and communication processes that
allow the web application to operate is the responsibility of the backend.
The backend operates behind the scenes managing data, processes requests, and
responding to them, while the frontend gives users a visual and interactive
experience. E-commerce platforms can also use event-driven architecture for
features like processing orders or updating inventory.

\subsection{Backend Frameworks}
\subsubsection{Express}
ExpressJS is a minimalist and flexible web application framework for Node.js,
designed to simplify server-side development. It's characterized by being
fast and unopinionated.
\subsubsection{Nestjs}
Nest JS is a node.js framework\cite{nestJS}
\subsubsection{JAVA Spring}

\subsubsection{Flask}

\subsubsection{ASP.NET Core}

\subsubsection{Laravel}

\subsection{Receiving IoT Events}

\subsection{Processing \& Routing Events}

\subsection{Security \& Authentication}


\section{APIs \& Real-Time Data Exposure}
The frontend and backend are two separate parts of the web application and are
usually running on two different servers. In order for them to communicate with
each other an Application Programming Interface (API) is needed. The API is the
part of the backend that its exposed to the outside and its the gateway to all
of the backend logic.
\subsection{REST vs GraphQL}
\subsection{WebSockets \& Server-Sent Events(SSE)}
\subsection{API Gateway \& Load Balancing}

\section{Database \& Storage}
\subsection{SQL}
\subsection{noSQL}
\subsection{Time-Series Databases}
\subsection{Data Caching}

\section{Frontend Development}
The frontend is the part of the web application that runs in the user's
browser and it's the part that the user can see and interact with.
It is divided into three parts: The markup, the styling and the scripting.
The markup defines the structure of the website, the styling is the part that
defines all of the styling of the page including colors fonts and empty spaces
(margins/paddings) and the scripting is the part that enables the interaction
of the user with the website, including buttons functionalities, form handling
etc..
It can be developed in many languages but all of them are in the end transpiled
to the languages that the browsers can understand which are: Hypertext markup
Language (HTML) for markup, Cascading Stylesheets (CSS) for styling and
Javascript (JS) for scripting.
With the advance of technology many libraries were created to facilitate the
development experience. In the following sections we will address the most
popular ones.

\subsection{Frameworks}

\subsubsection{ReactJS}
React JS is an open-source javascript library created by Facebook in 2013 that
simplifies the development of complex and dynamic user interfaces. Its the most widely
used library of its kind.
React applications are build using components. Components are reusable pieces of
code that represent a part of the UI, e.g. a button, a form or an entire section.
Each component has its own logic and styling and its declarative i.e. the
component defines what the UI should look like for a given state.
Components can be nested inside other components to build more complex UIs.
The components are developed using JavaScript for scripting and JavScript XML(JSX),
which is similar to HTML for markup.

A component can be written in two ways and therefore be of two types:
\begin{itemize}
	\item Functional component
	\item Class component
\end{itemize}

React uses a virtual Document Object Model (DOM) to optimize performance. A virtual
DOM is a lightweight in-memory representation of the real DOM, which is a
representation of the HTML structure in a tree-like structure. When a change
occur, it updates the virtual DOM first, then calculates the minimal changes needed
and then apply these changes to the real DOM\cite{bawane2022review}.


\subsubsection{Angular}
Angular is a typescript based framework used for building user interfaces.

\subsubsection{VueJS}

\subsection{Fullstack Frameworks}
\subsubsection{NextJS}
NextJS is a full-stack framework built on top of reactJS by vercel. This means
that NextJS can be used to develop both the frontend and backend parts of the
web application. Besides that, NextJS has several more advantages on ReactJS
adding features such as file-system based routing, server-side rendering (SSR)
and automatic code splitting.

One of Reactjs problems is that it doesn\'t have built-in support for routing,
meaning that the page routing needed to be handled using third party libraries
like react-router-dom. NextJS solves this issue by having a file-system based
routing. This works by automatically mapping every page file (a JSX/JS/TSX/TS
file named page) to an URL. This url is defined by the path of that file
relative to the app folder, which means that a file in app/report/test/page.tsx
is mapped to the endpoint report/test.

Another improvement of NextJS relative to ReactJS is that it allows SSR. In
Client Side Rendering, used by react, the server sends to the server a small
html document and a link to the javascript which the client needs to download
and run. On the other side, with SSR, the server sends to the browser the
full HTML document which it just needs to render\cite{Salanke_A.R_G.S_Dalali_2022}.

Apart from the clear performance increase, the SSR also improves the Search
Engine Optimization. This happens because the search engine scans the static
html page, and doesn\'t have into account the dynamic html created after by
the script. SEO can also be improved in another way, through the website
metadata (title, description, keyworks etc..) which NextJS also makes easier to
manage because of its ready-to-use Head component.

Another feature that improves the performance of projects using this framework
is the automatic code splitting. The automatic code splitting consists in
the separation of the javascript bundle into small parts that can be loaded
separately. This reduces significantly the page load time, by loading only the
parts that are needed to display the requested page.

\subsubsection{NuxtJS}
\subsubsection{Django}
\subsection{Real-time Event Handling}

\subsection{Ui for IoT Event Monitoring}

\subsection{State Management}

\section{Mobile Development}

\subsection{Native}
\subsubsection{Android}
\subsubsection{Swift}

\subsection{Cross-Platform}
\subsubsection{React Native}
\subsubsection{Flutter}

\subsection{Offline Mode \& Sync Strategies}

